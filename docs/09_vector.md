# Vector

[링크](https://www.cplusplus.com/reference/vector/vector/)

## vector description

``
template <class T, class Alloc = allocator<t> > class vector; // generic template
``

벡터는 sequence container 계열의 사이즈가 변하는 배열이다.
배열과 마찬가지로 벡터는 요소에 대해 연속적인 저장 위치를 사용한다.

즉, 요소에 대한 일반 포인터의 오프셋을 활용하여 요소에 액세스할 수 있으며, 배열과 마찬가지로 효율적이다. 그러나, 배열과 다르게 동적으로 변경될 수 있으며, 스토리지는 컨테이너에 의해 자동으로 처리된다.

<br/>
내부적으로 벡터는 동적으로 할당 된 배열을 사용하여 요소를 저장한다. 그리고 새 요소가 삽입될 때, 크기를 늘리기 위해 재할당될 수 있다. 이는 새 배열을 할당하고 모든 요소를 여기로 이동하는 것을 의미하기 때문에, 이는 처리 시간 측면에서 상대적으로 비용이 많이 드는 작업이다. 그래서 컨테이너에 추가될 때마다 벡터가 재할당되지는 않는다.

(그래서 컨테이너에 추가될 때마다 벡터가 재할당되지는 않는다. -> 무슨 말인지 모르겠다. 이론을 들어보면 재할당되는 것이 자연스러운 흐름인데, 재할당이 안된다는 말이 무슨 말일 까?)

<br/>
대신 벡터 컨테이너는 필요한 크기에 비해 더 큰 실제 용량을 가질 수 있다. 라이브러리는 메모리 사용량과 재할당 사이의 균형을 맞추기 위해 다양한 전략을 구현할 수 있지만, 어떤 경우에도 재할당은 대수적으로 증가하는 크기 간격에서만 발생하여 벡터 끝에 개별 요소를 삽입할 때 일정 시간을 제공할 수 있다. 복잡성 (push_back 참조).

<br/>
따라서 어레이와 비교할 때, 스토리지를 효율적인 방식으로 동적으로 활용할 수 있지만, 더 많은 메모리를 소비한다.

<br/>
다른 동적 시퀀스 컨테이너와 비교할 때, 벡터는 요소에 매우 효율적으로 액세스하고 끝에서 요소를 추가하거나 제거하는 데 상대적으로 효율적이다. 끝이 아닌 위치에 요소를 삽입하거나 제거하는 작업의 경우, 성능이 떨어지고, forward_list 보다 더 적은 consistent iterators 를 갖습니다.

## Properties

### Sequence
 엄격한 linear sequence. 개별 element 는 이 시퀀스의 위치에 따라 액세스된다.

### Dynamic array
 포인터 산술을 통해서도 sequence 의 모든 요소에 직접 액세스할 수 있으며, sequence 끝에서 element 를 비교적 빠르게 추가/제거할 수 있다.
 
### Allocator-aware
 컨테이너는 allocator 개체를 사용하여 저장소 요구 사항을 동적으로 처리한다.

## Template parameters

### T
 elements 의 type.

### Alloc
 스토리지 할당 모델을 정의하는 데 사용되는 할당자 개체의 유형입니다. 기본적으로 가장 간단한 메모리 할당 모델을 정의하고 값에 독립적 인 할당 자 클래스 템플릿이 사용됩니다.
멤버 유형 벡터 :: allocator_type으로 별칭이 지정됩니다.

